/**
 * @name containerd CVE-2021-32760漏洞检测规则
 * @description containerd CVE-2021-32760漏洞：近日Containerd公布了一个安全漏洞，
 * 攻击者通过构造一个恶意镜像，能够在普通用户进行pull和提取镜像时，
 * 修改用户宿主机上现存文件的文件权限。该漏洞不能直接读取，写入或者执行用户的文件。
 * CVE-2021-32760漏洞被评估为5.0 MEDIUM中危。
 * 关于该漏洞的详细信息，请参见https://github.com/containerd/containerd/security/advisories/GHSA-c72p-9xmj-rx3w。
 * @kind path-problem
 * @id go/zipslip
 * @problem.severity error
 * @security-severity 7.5
 * @precision high
 * @tags security
 *       external/cwe/cwe-022
 */

import go
import DataFlow::PathGraph
import semmle.go.security.TaintedPathCustomizations
import semmle.go.security.UnsafeUnzipSymlink::UnsafeUnzipSymlink


/**
 * Provides extension points for customizing the taint tracking configuration for reasoning about
 * zip-slip vulnerabilities.
 */
module CVE202132760 {
  
    /**
     * A data flow source for zip-slip vulnerabilities.
     */
    abstract class Source extends DataFlow::Node { }
  
    /**
     * A data flow sink for zip-slip vulnerabilities.
     */
    abstract class Sink extends DataFlow::Node { }
  
    /**
     * A sanitizer for zip-slip vulnerabilities.
     */
    abstract class Sanitizer extends DataFlow::Node { }
  
    /**
     * A sanitizer guard for zip-slip vulnerabilities.
     */
    abstract class SanitizerGuard extends DataFlow::BarrierGuard { }
  
    /**
     * A tar file header, as a source for zip slip.
     */
    class TarHeaderSource extends Source, DataFlow::Node {
      TarHeaderSource() {
        this =
          any(DataFlow::MethodCallNode mcn |
            mcn.getTarget().hasQualifiedName("archive/tar", "Reader", "Next")
          ).getResult(0)
      }
    }
  
    /**
     * A zip file header, as a source for zip slip.
     */
    class ZipHeaderSource extends Source {
      ZipHeaderSource() {
        exists(DataFlow::FieldReadNode frn, DataFlow::Node elbase |
          frn.getField().hasQualifiedName("archive/zip", "Reader", "File") and
          DataFlow::localFlow(frn, elbase)
        |
          DataFlow::readsAnElement(this, elbase)
        )
      }
    }
  
    /** A path-traversal sink, considered as a taint sink for zip slip. */
    class TaintedPathSinkAsSink extends Sink {
      TaintedPathSinkAsSink() {
        // and
        // Exclude `os.Symlink`, which is treated specifically in query `go/unsafe-unzip-symlink`.
        exists(DataFlow::CallNode c | c.getTarget().hasQualifiedName("os", "Symlink") |
          this = c.getAnArgument()
        )
        // and
        // exists(DataFlow::CallNode c| (c.getTarget().hasQualifiedName("os", "Chmod") and c.getArgument(0) = this))
      }
    }

    /**
     * Excludes zipped file data from consideration for zip slip.
     */
    class ZipFileOpen extends Sanitizer {
        ZipFileOpen() {
          this =
            any(DataFlow::MethodCallNode mcn |
              mcn.getTarget().hasQualifiedName("archive/zip", "File", "Open")
            ).getResult(0)
        }
    }

    /**
     * Excludes zipped file data from consideration for zip slip.
     */
    // class FSJoin extends Sanitizer {
    //     FSJoin() {
    //         exists(Function f |
    //           f.hasQualifiedName("path/filepath", "Join")
    //         and this = f.getACall())
    //     }
    // }

    class FSJoin extends Sanitizer {
        FSJoin() {
            this = 
            any(DataFlow::MethodCallNode mcn |
              mcn.getTarget().hasQualifiedName("path/filepath", "Join")).getResult(0)
        }
    }

    // private CallExpr getASymlinkCall() { result.getTarget().hasQualifiedName("os", "Symlink") }

    // class NotSymlink extends Sanitizer {
    //     NotSymlink() {
    //         this =
    //         any(DataFlow::MethodCallNode mcn |
    //         mcn.getTarget().hasQualifiedName("os", "Symlink")
    //         ).getResult(0)
    //     }
    // }

    /** A path-traversal sanitizer, considered as a sanitizer for zip slip. */
    class TaintedPathSanitizerAsSanitizer extends Sanitizer {
      TaintedPathSanitizerAsSanitizer() { this instanceof TaintedPath::Sanitizer }
    }
  
    /**
     * A sanitizer guard for zip-slip vulnerabilities which backtracks to sanitize expressions
     * that locally flow into a guarded expression. For example, an ordinary sanitizer guard
     * might say that in `if x { z := y }` the reference to `y` is sanitized because of the guard
     * `x`; these guards say that if the function begins
     * `f(p string) { w := filepath.Join(p); y := filepath.Dir(w) }` then both `p` and `w` are also
     * sanitized as expressions that contributed taint to `y`.
     *
     * This is useful because many sanitizers don't directly check the filename included in an archive
     * header, but some derived expression. It also propagates back from a field reference to its parent
     * (e.g. `hdr.Filename` to `hdr`), increasing the chances that a future reference to `hdr.Filename`
     * will also be regarded as clean (though SSA catches some cases of this).
     */
    class TaintedPathSanitizerGuardAsBacktrackingSanitizerGuard extends SanitizerGuard {
      TaintedPath::SanitizerGuard taintedPathGuard;
  
      TaintedPathSanitizerGuardAsBacktrackingSanitizerGuard() { this = taintedPathGuard }
  
      override predicate checks(Expr e, boolean branch) {
        exists(DataFlow::Node source, DataFlow::Node checked |
          taintedPathGuardChecks(taintedPathGuard, checked, branch) and
          taintFlowsToCheckedNode(source, checked)
        |
          e = source.asExpr()
        )
      }
    }

    pragma[noinline]
    private predicate taintedPathGuardChecks(
      TaintedPath::SanitizerGuard guard, DataFlow::Node checked, boolean branch
    ) {
      guard.checks(checked.asExpr(), branch)
    }
  
    pragma[noinline]
    private predicate taintFlowsToCheckedNode(DataFlow::Node source, DataFlow::Node checked) {
      taintedPathGuardChecks(_, checked, _) and
      (
        // Manual magic that is equivalent to `localTaint(source, checked)`
        source = checked
        or
        exists(DataFlow::Node succ |
          taintFlowsToCheckedNode(succ, checked) and
          TaintTracking::localTaintStep(source, succ)
        )
      )
    }

    class PrefixCheck extends SanitizerGuard, DataFlow::CallNode {
        PrefixCheck() {
          exists(Function f |
            f.hasQualifiedName("strings", "HasPrefix") and
            this = f.getACall()
          )
        }
    
        override predicate checks(Expr e, boolean branch) {
          e = this.getArgument(0).asExpr() and branch = true
        }
    }

    class DotDotCheck extends SanitizerGuard, DataFlow::CallNode {
        DotDotCheck() {
          exists(string dotdot | dotdot = ".." or dotdot = "../" or dotdot = "..\\" |
            this.getTarget().hasQualifiedName("strings", "Contains") and
            this.getArgument(1).getStringValue() = dotdot
          )
        }
    
        override predicate checks(Expr e, boolean branch) {
          e = this.getArgument(0).asExpr() and
          branch = false
        }
    }

    /**
   * A taint-tracking configuration for reasoning about zip-slip vulnerabilities.
   */
  class Configuration extends TaintTracking::Configuration {
    Configuration() { this = "CVE-2021-32760" }

    override predicate isSource(DataFlow::Node source) { source instanceof Source }

    override predicate isSink(DataFlow::Node sink) { sink instanceof Sink }

    override predicate isSanitizer(DataFlow::Node node) {
      super.isSanitizer(node) or
      node instanceof Sanitizer
    }

    override predicate isSanitizerGuard(DataFlow::BarrierGuard guard) {
      guard instanceof SanitizerGuard
    }
  }
}

from CVE202132760::Configuration cfg, DataFlow::PathNode source, DataFlow::PathNode sink
where cfg.hasFlowPath(source, sink)
select source.getNode(), source, sink,
"Unsanitized archive entry, which may contain '..', is used in a $@.", sink.getNode(),
"file system operation"
